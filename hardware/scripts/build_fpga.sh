#!/bin/bash
#
# FPGA NPU Build Script
# Automated FPGA synthesis, implementation, and bitstream generation
# Supports multiple boards and build configurations
#

set -e  # Exit on any error

# Script directory and project paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BUILD_DIR="$PROJECT_ROOT/build"

# Default configuration
BOARD="zcu102"
BUILD_TYPE="Release"
JOBS=4
CLEAN=false
VERBOSE=false
PROGRAM=false
SYNTHESIS_ONLY=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Usage function
usage() {
    cat << EOF
Usage: $0 [OPTIONS]

FPGA NPU Build Script - Automated synthesis and implementation

Options:
  -b, --board BOARD       Target board (zcu102, vcu118, default: zcu102)
  -t, --build-type TYPE   Build type (Debug, Release, default: Release)
  -j, --jobs N           Number of parallel jobs (default: 4)
  -c, --clean            Clean build directory before building
  -v, --verbose          Enable verbose output
  -p, --program          Program FPGA after successful build
  -s, --synthesis-only   Run synthesis only (skip implementation)
  -h, --help             Show this help message

Build Types:
  Debug    - Debug build with additional monitoring and slower timing
  Release  - Optimized build for performance and resource utilization

Supported Boards:
  zcu102   - Xilinx Zynq UltraScale+ ZCU102 evaluation board
  vcu118   - Xilinx Virtex UltraScale+ VCU118 evaluation board

Examples:
  $0                              # Build for ZCU102 (Release)
  $0 -b vcu118 -t Debug         # Debug build for VCU118
  $0 -c -v -p                    # Clean, verbose build, and program
  $0 -s -b zcu102               # Synthesis only for ZCU102
EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--board)
            BOARD="$2"
            shift 2
            ;;
        -t|--build-type)
            BUILD_TYPE="$2"
            shift 2
            ;;
        -j|--jobs)
            JOBS="$2"
            shift 2
            ;;
        -c|--clean)
            CLEAN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -p|--program)
            PROGRAM=true
            shift
            ;;
        -s|--synthesis-only)
            SYNTHESIS_ONLY=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Validate board selection
case $BOARD in
    zcu102|vcu118)
        ;;
    *)
        log_error "Unsupported board: $BOARD"
        log_error "Supported boards: zcu102, vcu118"
        exit 1
        ;;
esac

# Validate build type
case $BUILD_TYPE in
    Debug|Release)
        ;;
    *)
        log_error "Invalid build type: $BUILD_TYPE"
        log_error "Valid types: Debug, Release"
        exit 1
        ;;
esac

# Check for Vivado installation
check_vivado() {
    if ! command -v vivado &> /dev/null; then
        log_error "Vivado not found in PATH"
        log_error "Please source Vivado settings script or add to PATH"
        exit 1
    fi
    
    local vivado_version=$(vivado -version | grep Vivado | head -1)
    log_info "Found: $vivado_version"
}

# Setup build directory
setup_build_dir() {
    local build_subdir="$BUILD_DIR/${BOARD}_${BUILD_TYPE}"
    
    if [ "$CLEAN" = true ] && [ -d "$build_subdir" ]; then
        log_info "Cleaning build directory: $build_subdir"
        rm -rf "$build_subdir"
    fi
    
    mkdir -p "$build_subdir"
    BUILD_PATH="$build_subdir"
}

# Generate Vivado TCL script
generate_tcl_script() {
    local tcl_file="$BUILD_PATH/build_project.tcl"
    
    log_info "Generating Vivado TCL script: $tcl_file"
    
    cat > "$tcl_file" << EOF
# FPGA NPU Build Script for $BOARD ($BUILD_TYPE)
# Auto-generated by build_fpga.sh

# Create project
create_project fpga_npu_${BOARD} "$BUILD_PATH" -part [get_board_part_property [get_board_parts "*${BOARD}*"] PART_NAME]

# Set board part
set_property board_part [lindex [get_board_parts "*${BOARD}*"] 0] [current_project]

# Add RTL source files
add_files [glob "$PROJECT_ROOT/rtl/*.sv"]
set_property file_type "SystemVerilog" [get_files [glob "$PROJECT_ROOT/rtl/*.sv"]]

# Add constraint files
add_files -fileset constrs_1 [glob "$PROJECT_ROOT/constraints/*.xdc"]

# Set top module
set_property top npu_top [current_fileset]

# Set synthesis options based on build type
if {"$BUILD_TYPE" == "Debug"} {
    set_property strategy "Vivado Synthesis Defaults" [get_runs synth_1]
    set_property STEPS.SYNTH_DESIGN.ARGS.FLATTEN_HIERARCHY "none" [get_runs synth_1]
    set_property STEPS.SYNTH_DESIGN.ARGS.KEEP_EQUIVALENT_REGISTERS "true" [get_runs synth_1]
} else {
    set_property strategy "Flow_AreaOptimized_high" [get_runs synth_1]
    set_property STEPS.SYNTH_DESIGN.ARGS.DIRECTIVE "AreaOptimized_high" [get_runs synth_1]
}

# Set implementation options
if {"$BUILD_TYPE" == "Debug"} {
    set_property strategy "Vivado Implementation Defaults" [get_runs impl_1]
} else {
    set_property strategy "Performance_ExplorePostRoutePhysOpt" [get_runs impl_1]
    set_property STEPS.PLACE_DESIGN.ARGS.DIRECTIVE "ExploreWithRemap" [get_runs impl_1]
    set_property STEPS.ROUTE_DESIGN.ARGS.DIRECTIVE "Explore" [get_runs impl_1]
}

# Enable parallel processing
set_param general.maxThreads $JOBS

# Launch synthesis
launch_runs synth_1 -jobs $JOBS
wait_on_run synth_1

# Check synthesis results
if {[get_property PROGRESS [get_runs synth_1]] != "100%"} {
    puts "ERROR: Synthesis failed"
    exit 1
}

# Report synthesis results
open_run synth_1 -name synth_1
report_timing_summary -file "$BUILD_PATH/timing_summary_synth.rpt"
report_utilization -file "$BUILD_PATH/utilization_synth.rpt"

if {"$SYNTHESIS_ONLY" == "false"} {
    # Launch implementation
    launch_runs impl_1 -jobs $JOBS
    wait_on_run impl_1
    
    # Check implementation results
    if {[get_property PROGRESS [get_runs impl_1]] != "100%"} {
        puts "ERROR: Implementation failed"
        exit 1
    }
    
    # Generate reports
    open_run impl_1
    report_timing_summary -file "$BUILD_PATH/timing_summary_impl.rpt"
    report_utilization -file "$BUILD_PATH/utilization_impl.rpt"
    report_power -file "$BUILD_PATH/power_impl.rpt"
    report_drc -file "$BUILD_PATH/drc_impl.rpt"
    
    # Check timing closure
    set wns [get_property STATS.WNS [get_runs impl_1]]
    if {\$wns < 0} {
        puts "WARNING: Timing not met. WNS = \$wns ns"
        if {"$BUILD_TYPE" == "Release"} {
            puts "ERROR: Timing closure required for Release build"
            exit 1
        }
    } else {
        puts "INFO: Timing met. WNS = \$wns ns"
    }
    
    # Generate bitstream
    launch_runs impl_1 -to_step write_bitstream -jobs $JOBS
    wait_on_run impl_1
    
    # Check bitstream generation
    if {[get_property PROGRESS [get_runs impl_1]] != "100%"} {
        puts "ERROR: Bitstream generation failed"
        exit 1
    }
    
    puts "SUCCESS: Build completed successfully"
    puts "Bitstream: [glob $BUILD_PATH/fpga_npu_${BOARD}.runs/impl_1/*.bit]"
} else {
    puts "SUCCESS: Synthesis completed successfully"
}

# Close project
close_project
exit 0
EOF

    log_success "TCL script generated"
}

# Run Vivado build
run_vivado_build() {
    local tcl_file="$BUILD_PATH/build_project.tcl"
    local log_file="$BUILD_PATH/vivado_build.log"
    
    log_info "Starting Vivado build..."
    log_info "Build directory: $BUILD_PATH"
    log_info "Log file: $log_file"
    
    if [ "$VERBOSE" = true ]; then
        vivado -mode batch -source "$tcl_file" -log "$log_file" -journal "$BUILD_PATH/vivado_build.jou"
    else
        vivado -mode batch -source "$tcl_file" -log "$log_file" -journal "$BUILD_PATH/vivado_build.jou" > /dev/null
    fi
    
    # Check build result
    if grep -q "SUCCESS:" "$log_file"; then
        if [ "$SYNTHESIS_ONLY" = true ]; then
            log_success "Synthesis completed successfully"
        else
            log_success "Build completed successfully"
        fi
    else
        log_error "Build failed. Check log file: $log_file"
        exit 1
    fi
}

# Program FPGA
program_fpga() {
    if [ "$PROGRAM" = true ] && [ "$SYNTHESIS_ONLY" = false ]; then
        local bit_file=$(find "$BUILD_PATH" -name "*.bit" | head -1)
        
        if [ -n "$bit_file" ]; then
            log_info "Programming FPGA with bitstream: $bit_file"
            
            cat > "$BUILD_PATH/program.tcl" << EOF
open_hw_manager
connect_hw_server
open_hw_target
set_property PROGRAM.FILE {$bit_file} [get_hw_devices]
program_hw_devices [get_hw_devices]
close_hw_manager
exit
EOF
            
            vivado -mode batch -source "$BUILD_PATH/program.tcl"
            log_success "FPGA programming completed"
        else
            log_error "Bitstream file not found"
            exit 1
        fi
    fi
}

# Generate build summary
generate_summary() {
    local summary_file="$BUILD_PATH/build_summary.txt"
    
    cat > "$summary_file" << EOF
FPGA NPU Build Summary
======================

Board: $BOARD
Build Type: $BUILD_TYPE
Date: $(date)
User: $(whoami)
Host: $(hostname)

Build Configuration:
- Synthesis Only: $SYNTHESIS_ONLY
- Parallel Jobs: $JOBS
- Clean Build: $CLEAN
- Verbose: $VERBOSE
- Program FPGA: $PROGRAM

Build Artifacts:
- Project: $BUILD_PATH/fpga_npu_${BOARD}.xpr
- Reports: $BUILD_PATH/*.rpt
- Logs: $BUILD_PATH/*.log
EOF

    if [ "$SYNTHESIS_ONLY" = false ]; then
        local bit_file=$(find "$BUILD_PATH" -name "*.bit" | head -1)
        if [ -n "$bit_file" ]; then
            echo "- Bitstream: $bit_file" >> "$summary_file"
        fi
    fi
    
    cat >> "$summary_file" << EOF

Timing Summary:
EOF
    
    if [ -f "$BUILD_PATH/timing_summary_impl.rpt" ]; then
        grep -A 5 "Design Timing Summary" "$BUILD_PATH/timing_summary_impl.rpt" >> "$summary_file" || true
    fi
    
    log_info "Build summary saved: $summary_file"
}

# Main execution
main() {
    log_info "FPGA NPU Build Script"
    log_info "====================="
    log_info "Board: $BOARD"
    log_info "Build Type: $BUILD_TYPE"
    log_info "Jobs: $JOBS"
    
    # Check prerequisites
    check_vivado
    
    # Setup build environment
    setup_build_dir
    
    # Generate and run build
    generate_tcl_script
    run_vivado_build
    
    # Post-build actions
    program_fpga
    generate_summary
    
    log_success "Build process completed successfully!"
}

# Execute main function
main "$@"